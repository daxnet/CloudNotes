<#@ Include File="TemplateHeader.t4" #>
<#@ Modeling ElementType="Microsoft.VisualStudio.Uml.Classes.IClass" Processor="ModelingProcessor" ApplyStereotypes="CSharp" #>
<#@ Import Namespace="Microsoft.VisualStudio.Uml.AuxiliaryConstructs" #>
<#@ Import Namespace="Microsoft.VisualStudio.Uml.Classes" #>
<#@ Import Namespace="Microsoft.VisualStudio.ArchitectureTools.Extensibility.Uml" #>
<#@ Include File="CSharpCommentHelpers.t4" #>
<#@ Include File="CSharpHelpers.t4" #>
<#@ Output Extension=".cs" #>
<# 
    WriteAutoGeneratedWarningHeader();

    string classNamespace = GetNamespace(this.Element.Namespace);
    if(!string.IsNullOrEmpty(classNamespace))
    {
#>
namespace <#= classNamespace #>
{
<#
        PushIndent("\t");
    }

    WriteUsingStatements(this.Element);
    WriteLine("");
#>
<#
    WriteSummaryComment(this.Element.Description);
    WriteTemplateTypeParameterComments(TemplateParameterNameDescriptionPairs(this.Element));
    foreach(var comment in this.Element.GetModelStore().AllInstances<IComment>().Where(c => c.AnnotatedElements.Contains(this.Element)))
    {
        WriteRemarksComment(comment.Body);
    }
#>
<#
    WriteClassClrAttributes(this.Element);
#>
<#= ClassVisibility(this.Element) #><#= ClassUnsafeOption(this.Element) #><#= ClassStaticOption(this.Element) #><#= ClassAbstractOption(this.Element) #><#= ClassSealedOption(this.Element) #><#= ClassPartialOption(this.Element) #>class <#= ClassifierName(this.Element) #><#= ImplementedAndInheritedList(this.Element) #><# WriteClassifierConstraintOption(this.Element); #>
{
<#
    PushIndent("\t");

    // Write Attributes
    var ownedAttributes = this.Element.OwnedAttributes;
    foreach(IProperty attribute in ownedAttributes)
    {
        WriteSummaryComment(attribute.Description);
        WriteClassUmlPropertyDefinition(attribute);	
        WriteLine("");
    }
#>
<#
    // Write Associations
    var navigableOwnedEnds = GetNavigableOwnedEnds(this.Element, ownedAttributes);
    foreach(IProperty ownedEnd in navigableOwnedEnds) 
    {
        WriteSummaryComment(ownedEnd.OwningAssociation.Description);
        WriteSummaryComment(ownedEnd.Description);
        WriteClassUmlPropertyDefinition(ownedEnd);
        WriteLine("");
    }
#>
<#
    // Write Operations
    foreach(IOperation operation in this.Element.OwnedOperations)
    {
        WriteSummaryComment(operation.Description);
        foreach (IParameter parameter in operation.OwnedParameters.Where(p => p.Direction != ParameterDirectionKind.Return))
        {
            WriteParameterComment(parameter.Name, parameter.Description);
        }

        if(GetStereotype(operation) == "method")
        {
            WriteMethodClrAttributes(operation);
            if(IsConstructor(operation) || IsDestructor(operation))
            {
#>
<#= MethodVisibility(operation) #><#= operation.Name #>(<# WriteMethodParameterList(operation); #>)
{
}
<#
            }
            else
            {
#>
<#= MethodVisibility(operation) #><#= MethodUnsafeOption(operation) #><#= OperationStaticOption(operation) #><#= ClassMethodOverloadOption(operation, this.Element) #><#= MethodPartialOption(operation) #><#= MethodType(operation) #> <#= operation.Name #>(<# WriteMethodParameterList(operation); #>)<# WriteClassMethodBody(operation); #>
<#
            }

            WriteLine("");
        }
        else if(GetStereotype(operation) == "indexer") 
        {
            WriteIndexerClrAttributes(operation);
#>
<#= IndexerVisibility(operation) #><#= IndexerUnsafeOption(operation) #><#= OperationStaticOption(operation) #><#= ClassIndexerOverloadOption(operation, this.Element) #><#= IndexerType(operation) #> this[<# WriteIndexerParameterList(operation); #>]
{
<#
            PushIndent("\t");
#>
<#= IndexerGetVisibility(operation) #>get<# WriteClassIndexerAccessorBody(operation); #>
<#= IndexerSetVisibility(operation) #>set<# WriteClassIndexerAccessorBody(operation); #>
<#
            PopIndent();
#>
}
<#
            WriteLine("");
        }
    }

    PopIndent();
#>
}
<#
    ClearIndent();
    if(!string.IsNullOrEmpty(classNamespace))
    {
#>
}
<#  } #>

<#+
    #region Inheritance

    /// <summary>
    /// Gets the implemented and inherited types of the given class.
    /// </summary>
    /// <param name="aClass">The given class</param>
    /// <returns>implementedAndInherted types</returns>
    private static string ImplementedAndInheritedList(IClass aClass)
    {
        var list = ImplementedAndInheritedTypes(aClass);
		var implementedAndInheritedString = string.Empty;
        if(list.Any())
        {
            implementedAndInheritedString = " : " + string.Join(", ", list.Select(t => ElementType(t)));
        }
		if (aClass.AppliedStereotypes.Any(p => p.Name == "entity"))
        {
			if (!string.IsNullOrEmpty(implementedAndInheritedString))
				implementedAndInheritedString += ", Apworks.IEntity";
			else
				implementedAndInheritedString = " : Apworks.IEntity";
        }
		else if (aClass.AppliedStereotypes.Any(p => p.Name == "aggregateRoot"))
        {
			if (!string.IsNullOrEmpty(implementedAndInheritedString))
				implementedAndInheritedString += ", Apworks.IAggregateRoot";
			else
				implementedAndInheritedString = " : Apworks.IAggregateRoot";
        }
		return implementedAndInheritedString;
    }

    #endregion Inheritance

    #region Polymorphism

    /// <summary>
    /// Gets the overload option of the indexer.
    /// </summary>
    /// <param name="operation">The operation</param>
    /// <param name="owner">The class</param>
    /// <returns>The overload option for the operation</returns>
    private static string ClassIndexerOverloadOption(IOperation operation, IClass owner)
    {
        return ClassOperationOverloadOption(operation, owner);
    }

    /// <summary>
    /// Gets the overload option of the method.
    /// </summary>
    /// <param name="operation">The operation</param>
    /// <param name="owner">The class</param>
    /// <returns>The overload option for the operation</returns>
    private static string ClassMethodOverloadOption(IOperation operation, IClass owner)
    {
        if(string.IsNullOrEmpty(MethodPartialOption(operation)))
        {
            return ClassOperationOverloadOption(operation, owner);
        }
        else 
        {
            return string.Empty;
        }
    }

    /// <summary>
    /// Gets the overload option of the operation.
    /// </summary>
    /// <param name="operation">The operation</param>
    /// <param name="owner">The class</param>
    /// <returns>The overload option for the operation</returns>
    private static string ClassOperationOverloadOption(IOperation operation, IClass owner)
    {
        string overload = string.Empty;
        if(!string.IsNullOrEmpty(OperationAbstractOption(operation)))
        {
            overload += "abstract ";
        }
        else if(IsInheritedMember(operation, owner))
        {
            overload += "override ";
            if(!string.IsNullOrEmpty(OperationSealedOption(operation)))
            {
                overload += "sealed ";
            }
        }
        else if(IsOverridable(operation, owner))
        {
            overload += "virtual ";
        }

        return overload;
    }

    /// <summary>
    /// Gets the overload option of the property.
    /// </summary>
    /// <param name="property">The property</param>
    /// <param name="owner">The class</param>
    /// <returns>The overload option for the property</returns>
    private static string ClassPropertyOverloadOption(IProperty property, IClass owner)
    {
        string overload = string.Empty;
        if(IsInheritedMember(property, owner))
        {
            overload = "override ";
            if(!string.IsNullOrEmpty(PropertySealedOption(property)))
            {
                overload += "sealed ";
            }
        }
        else if(IsOverridable(property, owner))
        {
            overload += "virtual ";
        }

        return overload;
    }

    /// <summary>
    /// Checks if the operation is overridable.
    /// </summary>
    /// <param name="operation">The operation</param>
    /// <param name="owner">The class</param>
    /// <returns>true if the operation is an inherited member.</returns>
    private static bool IsOverridable(IOperation operation, IClass owner)
    {
        bool isPrivate = MethodVisibility(operation) == "private " || IndexerVisibility(operation) == "private ";
        return !isPrivate && string.IsNullOrEmpty(OperationStaticOption(operation)) && string.IsNullOrEmpty(OperationSealedOption(operation)) && HasVirtualMembers(owner);
    }

    /// <summary>
    /// Checks if the property is overridable.
    /// </summary>
    /// <param name="property">The property</param>
    /// <param name="owner">The class</param>
    /// <returns>true if the property is an inherited member.</returns>
    private static bool IsOverridable(IProperty property, IClass owner)
    {
        bool isPrivate = FieldVisibility(property) == "private " || PropertyVisibility(property) == "private ";
        return !isPrivate && string.IsNullOrEmpty(AttributeStaticOption(property)) && string.IsNullOrEmpty(PropertySealedOption(property)) && HasVirtualMembers(owner);
    }

    /// <summary>
    /// Checks if the classifier could have virtual memebers.
    /// </summary>
    /// <param name="aClass">The class</param>
    /// <returns>true if the property is an inherited member.</returns>
    private static bool HasVirtualMembers(IClass aClass)
    {
        return string.IsNullOrEmpty(ClassSealedOption(aClass)) && string.IsNullOrEmpty(ClassStaticOption(aClass));
    }

    /// <summary>
    /// Checks if the property is an inherited member.
    /// </summary>
    /// <param name="property">The property</param>
    /// <param name="owner">The owner class of the property</param>
    /// <returns>true if the property is an inherited member.</returns>
    private static bool IsInheritedMember(IProperty property, IClass owner)
    {
        var types = ImplementedOrInheritedTypes(owner);
        foreach(IType type in types) 
        {
            IClassifier baseClassifier = type as IClassifier;
            if(baseClassifier != null) 
            {
                ITemplateBinding templateBinding = GetTemplateBinding(baseClassifier);
                IClassifier bindingClassifier = GetBindingClassifier(templateBinding);
                if(bindingClassifier != null)
                {
                    baseClassifier = bindingClassifier;
                }

                foreach(IProperty propertyInBase in GetOwnedProperties(baseClassifier))
                {
                    bool isInheritedMember = IsInheritedMember(propertyInBase, property, templateBinding);
                    if(isInheritedMember)
                    {
                        return true;
                    }
                }
            }
        }

        return false;
    }

    /// <summary>
    /// Checks if the property is an inherited member.
    /// </summary>
    /// <param name="propertyInBase">The property in base</param>
    /// <param name="propertyInSubClass">The property in subclass</param>
    /// <param name="templateBinding">The template binding</param>
    /// <returns>true if the property in the subclass is an inherited member; false if it is not or the base is an interface</returns>
    private static bool IsInheritedMember(IProperty propertyInBase, IProperty propertyInSubClass, ITemplateBinding templateBinding)
    {
        var propertyInBaseOwner = propertyInBase.Owner;
        if(propertyInBaseOwner is IAssociation)
        {
            propertyInBaseOwner = ((IAssociation)propertyInBaseOwner).SourceElement;
        }

        if(propertyInBaseOwner is IInterface)
        {
            return false;
        }
        else if(propertyInBaseOwner is IClass)
        {
            bool isInheritedProperty = IsInheritedProperty(propertyInSubClass, propertyInBase, templateBinding);
            bool isOverridable = IsOverridable(propertyInBase, (IClass)propertyInBaseOwner);
            return isInheritedProperty && isOverridable;
        }
        
        return false;
    }
    
    /// <summary>
    /// Checks if the operation is an inherited member.
    /// </summary>
    /// <param name="operation">The operation</param>
    /// <param name="owner">The owning class of the operation</param>
    /// <returns>true if the operation is an inherited member.</returns>
    private static bool IsInheritedMember(IOperation operation, IClass owner)
    {
        var types = ImplementedOrInheritedTypes(owner);
        foreach(IType type in types) 
        {
            IClassifier baseClassifier = type as IClassifier;
            if(baseClassifier != null) 
            {
                ITemplateBinding templateBinding = GetTemplateBinding(baseClassifier);
                IClassifier bindingClassifier = GetBindingClassifier(templateBinding);
                if(bindingClassifier != null)
                {
                    baseClassifier = bindingClassifier;
                }

                foreach(IOperation operationInBase in GetOwnedOperations(baseClassifier))
                {
                    bool isInheritedMember = IsInheritedMember(operationInBase, operation, templateBinding);
                    if(isInheritedMember)
                    {
                        return true;
                    }
                }
            }
        }

        return false;
    }
    
    /// <summary>
    /// Checks if the operation is an inherited member.
    /// </summary>
    /// <param name="operationInBase">The operation in base</param>
    /// <param name="operationInSubClass">The operation in the subclass</param>
    /// <param name="templateBinding">The template binding</param>
    /// <returns>true if the operation in the subclass is an inherited member; false if it is not or the base is an interface</returns>
    private static bool IsInheritedMember(IOperation operationInBase, IOperation operationInSubClass, ITemplateBinding templateBinding)
    {
        var operationInBaseOwner = operationInBase.Owner;
        if(operationInBaseOwner is IAssociation)
        {
            operationInBaseOwner = ((IAssociation)operationInBaseOwner).SourceElement;
        }

        if(operationInBaseOwner is IInterface)
        {
            return false;
        }
        else if(operationInBaseOwner is IClass)
        {
            bool isInheritedOperation = IsInheritedOperation(operationInSubClass, operationInBase, templateBinding);
            bool isOverridable = IsOverridable(operationInBase, (IClass)operationInBaseOwner);
            return isInheritedOperation && isOverridable;
        }
        
        return false;
    }

    /// <summary>
    /// Checks if the operation in subclass is inherited from the operation in base.
    /// </summary>
    /// <param name="operationInSubClass">The operation in subClass</param>
    /// <param name="operationInBase">The operation in base</param>
    /// <param name="templateBinding">The template binding</param>
    /// <returns>if operation in subClass is inherited from the operation in base.</returns>
    private static bool IsInheritedOperation(IOperation operationInSubClass, IOperation operationInBase, ITemplateBinding templateBinding)
    {
        if(templateBinding == null)
        {
            return operationInSubClass.Signature == operationInBase.Signature;
        }

        if(operationInSubClass.Name != operationInBase.Name)
        {
            return false;
        }

        var subClassOperationOwnedParametersInOrder = GetOwnedParametersInOrder(operationInSubClass);
        var baseClassOperationOwnedParametersInOrder = GetOwnedParametersInOrder(operationInBase);
        int numOfSubClassOperationOwnedParameters = subClassOperationOwnedParametersInOrder.Count();
        if(numOfSubClassOperationOwnedParameters != baseClassOperationOwnedParametersInOrder.Count())
        {
            return false;
        }
       
        var parameterSubstitutions = templateBinding.ParameterSubstitutions;
         // find the newly defined template parameters
        var baseClassifier = (IClassifier)operationInBase.Owner;
        var subClassifier = (IClassifier)operationInSubClass.Owner;
        var subClassNewlyDefinedTemplateParameterNames = GetNewlyDefinedTemplateParameterNamesInSubClass(baseClassifier, subClassifier, parameterSubstitutions); 

        for(int i=0; i < numOfSubClassOperationOwnedParameters; i++)
        {
            var subClassOperationOwnedParameter = subClassOperationOwnedParametersInOrder.ElementAt(i);
            var baseClassOperationOwnedParameter = baseClassOperationOwnedParametersInOrder.ElementAt(i);
            if(subClassOperationOwnedParameter.Direction != baseClassOperationOwnedParameter.Direction)
            {
                return false;
            }

            bool isParameterInBaseEnumerable = IsEnumerable(baseClassOperationOwnedParameter);
            bool isParameterInSubClassEnumerable = IsEnumerable(subClassOperationOwnedParameter);
            if(isParameterInBaseEnumerable != isParameterInSubClassEnumerable)
            {
                return false;
            }

            if(!OneTypeOverridesTheOther(baseClassOperationOwnedParameter.Type, subClassOperationOwnedParameter.Type, parameterSubstitutions, subClassNewlyDefinedTemplateParameterNames))
            {
                return false;
            }
       }

       return true;
    }

    /// <summary>
    /// Gets the owned parameters in order: first is the parameter of return type, and then the rest of the parameters.
    /// </summary>
    /// <param name="operation">The operation</param>
    /// <returns>List of owned parameters in order</returns>
    private static List<IParameter> GetOwnedParametersInOrder(IOperation operation)
    {   
        var orderedSet = Enumerable.Union<IParameter>(operation.OwnedParameters.Where(parameter => parameter.Direction == ParameterDirectionKind.Return), operation.OwnedParameters.Where(parameter => parameter.Direction != ParameterDirectionKind.Return));
        return orderedSet.ToList();
    }

    /// <summary>
    /// Checks if the two type names are equal with considering of the template binding substitutions.
    /// </summary>
    /// <param name="propertyInSubClass">The property in subClass</param>
    /// <param name="propertyInBase">The property in base</param>
    /// <param name="templateBinding">The template binding</param>
    /// <returns>if property in subClass is inherited from the property in base.</returns>
    private static bool IsInheritedProperty(IProperty propertyInSubClass, IProperty propertyInBase, ITemplateBinding templateBinding)
    {
        if(templateBinding == null)
        {
            return propertyInSubClass.Signature == propertyInBase.Signature;
        }

        if(propertyInSubClass.Name != propertyInBase.Name)
        {
            return false;
        }
        
        bool isPropertyInBaseEnumerable = IsEnumerable(propertyInBase);
        bool isPropertyInSubClassEnumerable = IsEnumerable(propertyInSubClass);
        if(isPropertyInBaseEnumerable != isPropertyInSubClassEnumerable)
        {
            return false;
        }

        var parameterSubstitutions = templateBinding.ParameterSubstitutions;
        var subClassNewlyDefinedTemplateParameterNames = GetNewlyDefinedTemplateParameterNamesInSubClass(propertyInBase.Classifier, propertyInSubClass.Classifier, parameterSubstitutions); 

        return OneTypeOverridesTheOther(propertyInBase.Type, propertyInSubClass.Type, parameterSubstitutions, subClassNewlyDefinedTemplateParameterNames);
    }

    /// <summary>
    /// Checks if the type in subclass overrides the type in base.
    /// </summary>
    /// <param name="typeInBase">The type in base</param>
    /// <param name="typeInSubclass">The type in subclass</param>
    /// <param name="parameterSubstitutions">The parameter substitutions</param>
    /// <param name="newlyDefinedTemplateParameterNames">The newly defined template parameter names in subclass</param>
    /// <returns>true if the type in subclass overrides the type in the base; false otherwise</returns>
    private static bool OneTypeOverridesTheOther(IType typeInBase, IType typeInSubclass, IEnumerable<ITemplateParameterSubstitution> parameterSubstitutions, IEnumerable<string> newlyDefinedTemplateParameterNames)
    {
        // get name and template parameters for base
        List<string> baseTypeTemplateParametersNames = new List<string>();
        string baseTypeName = GetNameAndTemplateParameterNamesForType(typeInBase, out baseTypeTemplateParametersNames);

        // get name and template parameters for subclass
        List<string> subTypeTemplateParametersNames = new List<string>();
        string subTypeName = GetNameAndTemplateParameterNamesForType(typeInSubclass, out subTypeTemplateParametersNames);

        if(newlyDefinedTemplateParameterNames.Contains(subTypeName) || subTypeTemplateParametersNames.Where(name => newlyDefinedTemplateParameterNames.Contains(name)).Any())
        {
            return false;
        }

        int numberOfSubTypeTemplateParameters = subTypeTemplateParametersNames.Count();
        if(numberOfSubTypeTemplateParameters != baseTypeTemplateParametersNames.Count())
        {
            return false;
        }

        if(subTypeTemplateParametersNames.Any())
        {
            if(baseTypeName != subTypeName)
            {
                return false;
            }
            
            for(int i=0; i < numberOfSubTypeTemplateParameters; i++)
            {
                var subTypeTemplateParameterName = subTypeTemplateParametersNames.ElementAt(i);
                var baseTypeTemplateParameterName = baseTypeTemplateParametersNames.ElementAt(i);

                if(!OneTypeNameOverridesTheOther(baseTypeTemplateParameterName, subTypeTemplateParameterName, parameterSubstitutions))
                {
                    return false;
                }
            }

            return true;
        }
        else 
        {
            return OneTypeNameOverridesTheOther(baseTypeName, subTypeName, parameterSubstitutions);
        }
    }
    
    /// <summary>
    /// Checks if the type name in subclass overrides the type name in base.
    /// </summary>
    /// <param name="baseTypeName">The type name in base</param>
    /// <param name="subTypeName">The type name in subclass</param>
    /// <param name="parameterSubstitutions">The parameter substitutions</param>
    /// <returns>true if the type name in subclass could override the type in the base; false otherwise</returns>
    private static bool OneTypeNameOverridesTheOther(string baseTypeName, string subTypeName, IEnumerable<ITemplateParameterSubstitution> parameterSubstitutions)
    {
        bool found = false;
        bool hasSubstitution = false;
        foreach(var substitution in parameterSubstitutions)
        {
            if(substitution.Formal.ParameteredElement.Name == baseTypeName)
            {
                hasSubstitution = true;
                INamedElement actual = substitution.Actuals.FirstOrDefault();
                if(actual != null && subTypeName == actual.Name) 
                {
                    found = true;
                    break;
                }
            }
        }

        if(hasSubstitution && !found)
        {
            return false;
        }

        if(!hasSubstitution && baseTypeName != subTypeName)
        {
            return false;
        }

        return true;
    }

    /// <summary>
    /// Gets the name and template parameter names as a list for the given type.
    /// </summary>
    /// <param name="aType">the type to query</param>
    /// <param name="templateParameterNames">the template parameter names for the type</param>
    /// <returns>The type name</returns>
    private static string GetNameAndTemplateParameterNamesForType(IType aType, out List<string> templateParameterNames) 
    {
        string typeName = null;
        IClassifier classifier = aType as IClassifier;
        templateParameterNames = new List<string>();
        if(classifier != null)
        {
            templateParameterNames = GetNameAndTemplateParameterNamesForClassifier(classifier);
            if(templateParameterNames.Any())
            {
                typeName = templateParameterNames.ElementAt(0);
                templateParameterNames.RemoveAt(0);
            }
        }
        else 
        {
            typeName = ElementType(aType);
        }    

        return typeName;
    }

    /// <summary>
    /// Gets the classifier name and template parameter names as a list.
    /// </summary>
    /// <param name="classifier">the classifier to query</param>
    /// <returns>a list of classifier name and template parameter names for the given classifier</returns>
    private static List<string> GetNameAndTemplateParameterNamesForClassifier(IClassifier classifier) 
    {
        return ClassifierProperty(element => { return GetName(element); }, GetUnboundClassifierName, SimpleAssemble, classifier).ToList();
    }

    /// <summary>
    /// Gets the classifier name and template parameter names as a list.
    /// </summary>
    /// <param name="baseClass">the base class</param>
    /// <param name="subClass">the sub class</param>
    /// <param name="parameterSubstitutions">the parameter substitutions</param>
    /// <returns>The template parameter newly defined in the subclass</returns>
    private static IEnumerable<string> GetNewlyDefinedTemplateParameterNamesInSubClass(IClassifier baseClassifier, IClassifier subClassifier, IEnumerable<ITemplateParameterSubstitution> parameterSubstitutions)
    {
        var baseClassTemplateParameterNames = TemplateParameterNames(baseClassifier);
        var substitutedTemplateParameterNames = GetSubstitutedTemplateParameterNames(parameterSubstitutions);
        var nonSubstitutedTemplateParameterNames = baseClassTemplateParameterNames.Where(name => !substitutedTemplateParameterNames.Contains(name));

        var subClassTemplateParameterNames = TemplateParameterNames(subClassifier);
        return subClassTemplateParameterNames.Where(name => !nonSubstitutedTemplateParameterNames.Contains(name));
    }

    /// <summary>
    /// Gets the list of template parameter names that are substituted.
    /// </summary>
    /// <param name="parameterSubstitutions">the parameter substitutions</param>
    /// <returns>The list of template parameter names that are substituted.</returns>
    private static List<string> GetSubstitutedTemplateParameterNames(IEnumerable<ITemplateParameterSubstitution> templateParameterSubstitutions)
    {
        List<string> substitutedParameterNames = new List<string>();
        foreach(var substitute in templateParameterSubstitutions)
        {
            string formalName = substitute.Formal.ParameteredElement.Name;
            string actualName = null;
            if(substitute.Actuals.Any())
            {
                actualName = substitute.Actuals.ElementAt(0).Name;
            }

            if(!string.IsNullOrWhiteSpace(formalName))
            {
                if(!string.IsNullOrWhiteSpace(actualName) && formalName == actualName)
                {
                    continue;
                }
                else 
                {
                    substitutedParameterNames.Add(formalName);
                }
            }
        }

        return substitutedParameterNames;
    }

    /// <summary>
    /// Gets the owned attributes for the given classifier.
    /// </summary>
    /// <param name="classifier">The classifier</param>
    /// <returns>The owned attributes</returns>
    private static IEnumerable<IProperty> GetOwnedProperties(IClassifier classifier)
    {
        var ownedAttributes= GetOwnedAttributes(classifier);
        var navigableOwnedEnds = GetNavigableOwnedEnds(classifier, ownedAttributes);
        return Enumerable.Union<IProperty>(ownedAttributes, navigableOwnedEnds);
    }

    /// <summary>
    /// Gets the owned attributes for the given classifier.
    /// </summary>
    /// <param name="classifier">The classifier</param>
    /// <returns>The owned attributes</returns>
    private static IEnumerable<IProperty> GetOwnedAttributes(IClassifier classifier)
    {
        if(classifier is IClass)
        {
            return ((IClass)classifier).OwnedAttributes;
        }
        else if(classifier is IInterface)
        {
            return ((IInterface)classifier).OwnedAttributes;
        }

        return Enumerable.Empty<IProperty>();
    }

    /// <summary>
    /// Gets the owned operations for the given classifier.
    /// </summary>
    /// <param name="classifier">The classifier</param>
    /// <returns>The owned operations</returns>
    private static IEnumerable<IOperation> GetOwnedOperations(IClassifier classifier)
    {
        if(classifier is IClass)
        {
            return ((IClass)classifier).OwnedOperations;
        }
        else if(classifier is IInterface)
        {
            return ((IInterface)classifier).OwnedOperations;
        }

        return Enumerable.Empty<IOperation>();
    }

    #endregion Polymorphism

    #region Class property options

    /// <summary>
    /// Gets the sealed option.
    /// </summary>
    /// <param name="aClass">The class</param>
    /// <returns>The sealed keyword option</returns>
    private static string ClassSealedOption(IClass aClass)
    {
        return aClass.IsLeaf ? "sealed " : string.Empty;
    }

    /// <summary>
    /// Gets the abstract option.
    /// </summary>
    /// <param name="aClass">The class</param>
    /// <returns>The abstract keyword option</returns>
    private static string ClassAbstractOption(IClass aClass)
    {
        return aClass.IsAbstract ? "abstract " : string.Empty;
    }

    /// <summary>
    /// Gets the unsafe option.
    /// </summary>
    /// <param name="aClass">The class</param>
    /// <returns>The static keyword option</returns>
    private static string ClassUnsafeOption(IClass aClass) 
    {
        return GetProperty(aClass, "class", "IsUnsafe", "unsafe");
    }

    /// <summary>
    /// Gets the static option.
    /// </summary>
    /// <param name="aClass">The class</param>
    /// <returns>The static keyword option</returns>
    private static string ClassStaticOption(IClass aClass) 
    {
        return GetProperty(aClass, "class", "IsStatic", "static");
    }

    /// <summary>
    /// Gets the partial option.
    /// </summary>
    /// <param name="aClass">The class</param>
    /// <returns>The partial keyword option</returns>
    private static string ClassPartialOption(IClass aClass) 
    {
        return GetProperty(aClass, "class", "IsPartial", "partial");
    }

    #endregion Class property options

    #region Operations

    /// <summary>
    /// Check if the operation is a destructor.
    /// </summary>
    /// <param name="operation">The operation</param>
    /// <returns>true if the operation is a destructor.</returns>
    private static bool IsDestructor(IOperation operation)
    {
        if (operation.Owner is IClassifier)
        {
            IClassifier owner = (IClassifier)operation.Owner;
            return operation.Name == "~" + owner.Name;
        }

        return false;
    }

    /// <summary>
    /// Write UmlProperty definition.
    /// </summary>
    /// <param name="property">The uml IProperty</param>
    private void WriteClassUmlPropertyDefinition(IProperty property)
    {
        string overloadOption = ClassPropertyOverloadOption(property, this.Element);
        WriteUmlPropertyDefinition(property, overloadOption);
    }

    /// <summary>
    /// Write the method body
    /// </summary>
    /// <param name="operation">The operation</param>
    private void WriteClassMethodBody(IOperation operation)
    {
        if(!operation.IsAbstract && string.IsNullOrEmpty(MethodPartialOption(operation)))
        {
            WriteDefaultImplementation();
        }
        else
        {
            Write(";");
            WriteLine("");
        }
    }

    /// <summary>
    /// Writes the indexer accessor body.
    /// </summary>
    /// <param name="operation">The operation</param>
    private void WriteClassIndexerAccessorBody(IOperation operation)
    {
        WriteClassMethodBody(operation);
    }

    #endregion Operations

    #region Visibility

    /// <summary>
    /// Returns the visibility of the given class.
    /// </summary>
    /// <param name="aClass">The class</param>
    /// <returns>public, protected, protected internal, internal, or private</returns>
    private static string ClassVisibility(IClass aClass)
    {
        return Visibility(aClass, "class", "PackageVisibility");
    }

    #endregion Visibility
#>
<#+
    protected override bool AppliesToElement()
    {
        bool isTemplate = this.Element.IsTemplate;
        bool isBoundElement = this.Element.TemplateBindings != null && this.Element.TemplateBindings.Any();
        return !isTemplate && !isBoundElement && GetStereotype(this.Element) == "class";
    }
#>
